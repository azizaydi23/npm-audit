import { readFileSync } from 'node:fs';
import { readdir } from 'node:fs/promises';
import path from 'path';

if (process.argv.length <= 2) {
  console.error(`Usage: node --permission --allow-fs-read ... ${process.argv[1]} "<directory>,<directory2>,..."`);
  console.error(`Example: node --permission --allow-fs-read c:/ ${process.argv[1]} "c:/repos,c:/more/repos"`);
  process.exit(1);
}
const scanDirs = process.argv[2].split(',').map(dir => dir.trim());

console.log(`Starting scan for malicious npm packages in the following directories: ${scanDirs.join(', ')}`)
console.log(`Be sure to set node --allow-fs-read=... for all dirs, so nodejs can read it`);

let counter = 0

const maliciousPackages = {
  // https://jfrog.com/blog/new-compromised-packages-in-largest-npm-attack-in-history/
  'backslash': { versions: [ '0.2.1' ] },
  'chalk-template': { versions: [ '1.1.1' ] },
  'supports-hyperlinks': { versions: [ '4.1.1' ] },
  'has-ansi': { versions: [ '6.0.1' ] },
  'simple-swizzle': { versions: [ '0.2.3' ] },
  'color-string': { versions: [ '2.1.1' ] },
  'error-ex': { versions: [ '1.3.3' ] },
  'color-name': { versions: [ '2.0.1' ] },
  'is-arrayish': { versions: [ '0.3.3' ] },
  'slice-ansi': { versions: [ '7.1.1' ] },
  'color-convert': { versions: [ '3.1.1' ] },
  'wrap-ansi': { versions: [ '9.0.1' ] },
  'ansi-regex': { versions: [ '6.2.1' ] },
  'supports-color': { versions: [ '10.2.1' ] },
  'strip-ansi': { versions: [ '7.1.1' ] },
  'chalk': { versions: [ '5.6.1' ] },
  'debug': { versions: [ '4.4.2' ] },
  'ansi-styles': { versions: [ '6.2.2' ] },
  'proto-tinker-wc': { versions: [ '0.1.87' ] },
  'prebid': { versions: [ '10.9.1', '10.9.2' ] },
  '@coveops/abi': { versions: [ '2.0.1' ] },
  'duckdb': { versions: [ '1.3.3' ] },
  '@duckdb/node-bindings': { versions: [ '1.3.3' ] },
  '@duckdb/duckdb-wasm': { versions: [ '1.29.2' ] },
  '@duckdb/node-api': { versions: [ '1.3.3' ] },

  // https://socket.dev/blog/npm-is-package-hijacked-in-expanding-supply-chain-attack
  'eslint-config-prettier': { versions: [ '8.10.1', '9.1.1', '10.1.6', '10.1.7' ] },
  'eslint-plugin-prettier': { versions: [ '4.2.2', '4.2.3' ] },
  'synckit': { versions: [ '0.11.9' ] },
  '@pkgr/core': { versions: [ '0.2.8' ] },
  'napi-postinstall': { versions: [ '0.3.1' ] },
  'got-fetch': { versions: [ '5.1.11', '5.1.12' ] },
  'is': { versions: [ '3.3.1', '5.0.0' ] },

  // https://github.com/nrwl/nx/security/advisories/GHSA-cxm3-wv7p-598c
  '@nx/devkit': { versions: [ '21.5.0', '20.9.0' ] },
  '@nx/enterprise-cloud': { versions: [ '3.2.0' ] },
  '@nx/eslint': { versions: [ '21.5.0' ] },
  '@nx/js': { versions: [ '21.5.0', '20.9.0' ] },
  '@nx/key': { versions: [ '3.2.0' ] },
  '@nx/node': { versions: [ '21.5.0', '20.9.0' ] },
  '@nx/workspace': { versions: [ '21.5.0', '20.9.0' ] },
  'nx': { versions: [ '21.5.0', '20.9.0', '20.10.0', '21.6.0', '20.11.0', '21.7.0', '21.8.0', '20.12.0' ] },
}

const evilVersions = [];
const knownEvilVersionsButNotUsingThem = [];
const noKnownEvilVersions = [];
const skippedNoNameOrVersion = [];
const parsingErrors = [];

const findPackageJsons = async (dir) => {
   const list = await readdir(dir, { recursive: true });
   return list.filter(file => file.endsWith('package.json')).map(file => path.resolve(dir, file));
}

const checkFile = (filePath) => {
  const data = readFileSync(filePath, 'utf8')
  counter++;
  if (counter % 500 === 0) {
    console.log(`Checked ${counter} package.json files...`);
  }

  let content
  try {
    content = JSON.parse(data);
  } catch(err) {
    parsingErrors.push(`Error parsing ${filePath}: ${err.message}`);
    return
  }

  if (!content.name || !content.version) {
    skippedNoNameOrVersion.push(`Skipping ${filePath} as it does not have a name or version field`);
    return
  }

  if (!maliciousPackages[content.name.trim()]) {
    noKnownEvilVersions.push(`Checked ${filePath}, no issues found in ${content.name}@${content.version}.`)
    return
  }
  
  const maliciousVersions = maliciousPackages[content.name].versions
  if (maliciousVersions.includes(content.version.trim())) {
    evilVersions.push(`☠️ Malicious package found: ${content.name}@${content.version} in ${filePath}`)
  } else {
    knownEvilVersionsButNotUsingThem.push(`Unaffected ${content.name}@${content.version} in ${filePath}. Evil versions are: ${maliciousVersions.join(', ')}`)
  }
};

for (const scanDir of scanDirs) {
  console.log(`Scanning directory: ${scanDir}`);
  const packageJsonFiles = await Promise.all(await findPackageJsons(scanDir));
  packageJsonFiles.map(file => checkFile(file));
}


console.log(`Scan complete. Checked a total of ${counter} package.json files in the folders ${scanDirs.join(', ')}`);
console.log(`${skippedNoNameOrVersion.length} files were skipped as they did not have a name or version field`);
console.log(`${parsingErrors.length} files were skipped as they do not contain valid JSON content: ${JSON.stringify(parsingErrors, null, 2)}`);
console.log(`${noKnownEvilVersions.length} dont have any known malicious versions`);
console.log(`${knownEvilVersionsButNotUsingThem.length} of your files are known, that they were affected once, but you use an unaffected version, as far as we know. Here is the list: ${JSON.stringify(knownEvilVersionsButNotUsingThem.sort(), null, 2)} `);

if (evilVersions.length === 0) {
  console.log(`We did not find malicious packages by inspecting your local package.jsons inside the folders ${scanDirs.join(', ')}. ⚠️ But be be aware, we only checked for a small set of known malicious packages. There might be others, that we dont know yet`);
} else {
  console.log(`⚠️⚠️⚠️⚠️⚠️`);
  console.log(`THATS NOT GOOD. We found ${evilVersions.length} malicious packages in your package.json files! Please remove them ASAP and consider talk to your ISM team! Here is the list: ${JSON.stringify(evilVersions.sort(), null, 2)}`);
}
